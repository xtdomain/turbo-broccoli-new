Описание: 

Пишем свой фреймворк - версия 3 - 
теперь каждой таблице назначен контроллер (вместо действия), 
каждый контроллер помнит весь путь url вместе со страницей, 
каждый контроллер можно вызвать где угодно(задаются ограничения), 
теперь основной контроллер defaultController работает всегда в публичной части (в нем вид страницы, кнопка входа в личный кабинет) и нет необходимости
 вызывать экземпляры при каждом действии или прописывать его вид во всех контроллерах.

добавлена система шаблонов/слоев - если необходим шаблон - запускаем роутер в виде (пример: $content->addRoute(), 
 в самом роутере в методе mainRoute() запускаем шаблон

можно изменить вид всех слоев - просто изменить html код шаблона.
в даный момент все контроллеры вызываются как в публичной части так и в админской - можно задавать ограничения в роутере
шаблонов и видов может быть сколько угодно

принцип работы:
 config запускает метод mainRoute() - этот метод запускает контроллер, который в свою очередь вызывает шаблон, последний подключает роутер.
 

 ФАЙЛЫ:

index.php - точка входа
route - управляет подключением контроллеров/моделей и вызывает ошибки
config - константы контроллера/модели/вида
bd - поключение к БД


КОНТРОЛЛЕРА всего 5:
 
default - общий вид сайта, header/footer, кнопка домой, форма регистрации
goods - таблица товаров +фильтр товаров (если категория выбрана в контроллере table)
category - таблица категорий
tables - страница выбранного товара, отражает все категории товара, с выбором категорий
admin_table - таблица связей для внесения изменений в БД
admin - контроллер редактирования БД, (в разработке)
out - контроллер выхода - завершает сессию и покидает админ-часть


 ВИДЫ:

шаблоны main.tpl.php и admin.tpl.php
остальные реализованы как слои


 ОШИБКИ: 

1) ошибка с вызовом header в шаблоне, если роутер вызывается не на первой строке. Временное решение - вызывать header напрямую из роутера



    !!!Подсказки по созданию контроллеров, моделей, видов!!!

1. Создать контроллер

class adminController extends Controller{
 private $pageTpl = "/views/admin.tpl.php";
  public function __construct() {
   $this->model = new adminModel();
   $this->view = new View();
  }
 public function default() {
  View::render($this->pageTpl, $this->pageData); //вызвать вид
 }
Если будет пагинация то обязательно:
  public function page() {
   $this->default(); //вернется в контроллер, всю остальную информацию берет из родительских классов
  }
Далее создаем свои методы.


2. Создать модель

//подключение реализовано в родительском классе Model

class adminModel extends Model {
 public static $id = idG; //здесь указываем поле по которому считаем количество записей БД (нужно для пагинации)
 public $maxNotes = 1;// сколько строк выводить на этой странице (нужно для пагинации)
  public function goods_tables() {
                                              //запрос в базу данных 1) указать группировку 2) указать LIMIT: 0 - показывать все, 1 - постранично 
                                              //3) ограничение where - где 0 - отключить, а любой текст соответствует наименованию категории
    $result = self::goods_table(name, 1, 0);
    return $result;
  }
}


3. Создать вид

Если шаблон - добавить: $content->addRoute(), а также перед html тегами - $content->startRoute('название шаблона')
Нет обязательных требований.


Из роутера в каждый контроллер передается имя вызванного контроллера - теперь при создании 
нового вида можно использовать переменные, вместо того чтобы везде прописывать имя контроллера

 Пример: пагинация - ожидаемый url 

  http://catalog-site.example.ru/goods/1/ - где goods - контроллер goodsController
  http://catalog-site.example.ru/category/1/ где category - categoryController, 

 вместо этого используется одинаковая конструкция:

  http://catalog-site.example.ru/$pageData[saveUrlBefore]/$pageData[save]/$i/$pageData[saveUrlAfter]

 где * $pageData[saveUrlBefore] = сохраненый путь до контроллера
     * $pageData[saveUrlAfter] = сохраненый путь после контроллера и его действия
     * $pageData[onlyTemplate] = имя шаблона - ситуация когда не нужно сохранять путь до контроллера, а просто вернуться в основную дирректорию шаблона
 
   пример: вместо http://catalog-site.example.ru/admin/category/1/goods/1/table/3
                  http://catalog-site.example.ru/admin/table/3 - где admin - это шаблон

     * $pageData[save] = имя текущего контроллера (goods, category, table, admin и тд.)



Кнопка "показывать все" просто отправляет по ссылке /category/1/goods/1/
путь сохраняется только в пределах этой ссылки или изменений урл напрямую пользователем
кнопка находится в шаблоне


Принцип работы метода пагинация:

В контроллере: 
 $pagination = $this->model->Pagination('category'); // Подключение пагинации (прописываем 'category')
 $this->pageData['pagination'] = $pagination; // Отдать в Вид

В виде: 
 echo($pageData['pagination']);

принцип:
 модель не трогаем - метод уже есть в родительской модели. Текущий контроллер его запустит и передаст ссылку(ссылку вносим сами).
 ссылка не что иное, как имя контроллера, одако внести это имя необходимо, так как пока контроллер не запущен - имя еще не известно.
 Метод пагинация сам вычисляет количесвто страниц на текущем контроллере, возвращает строку ссылок по типу 1 2 3 ...


ПОСЛЕДНИЕ ИЗМЕНЕНИЯ:

05.12.2019 - сокращен код в моделях и контроллерах
10.12.2019 - добавлена система шаблонов/слоев, оптимизация работы
17.12.2019 - пагинация теперь просто вызывается из вида; упрощена работа метода user_account; добавлена иконка
20.12.2019 - визуальные изменения файла error-404, ошибки вынесены в отдельный метод роутера, включаются в файле config.php, способ вызов роутера из шаблона упрощен (создание класса теперь вынесено в View.php)
26.12.2019 - переоформление: теперь можно в виде вызвать табличное (echo($pageData['printTable'])) оформление или блочное (echo($pageData['printDiv'])) 
                отображение пагинации в виде (echo $pageData['pagination']), добавлен метод перевода любого массива в обычный текст; стили теперь подключаются отдельно
   
   Добавлен метод (будет доработан) в роутер startRoute() - теперь имя шаблона передается заранее перед html тегами: <?php $content->startRoute('default') ?>
      используется для видов account.tpl и accaunt.exit.tpl, (и для всех остальных) теперь кнопка "на главную возвращает в текущий шаблон", для выхода из админ нужно выйти