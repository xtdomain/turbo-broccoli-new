Описание:

Пишем свой фреймворк - версия 3 -
теперь каждой таблице назначен контроллер (вместо действия),
каждый контроллер помнит весь путь url вместе со страницей,
каждый контроллер можно вызвать где угодно(задаются ограничения),
теперь основной контроллер defaultController работает всегда в публичной части (в нем вид страницы, кнопка входа в личный кабинет) и нет необходимости
 вызывать экземпляры при каждом действии или прописывать его вид во всех контроллерах.

добавлена система шаблонов/слоев - если необходим шаблон - запускаем роутер в виде (пример: $content->addRoute(),
 в самом роутере в методе mainRoute() запускаем шаблон

можно изменить вид всех слоев - просто изменить html код шаблона.
в даный момент все контроллеры вызываются как в публичной части так и в админской - можно задавать ограничения в роутере
шаблонов и видов может быть сколько угодно

принцип работы:
 config запускает метод mainRoute() - этот метод запускает контроллер, который в свою очередь вызывает шаблон, последний подключает роутер.


 ФАЙЛЫ:

index.php - точка входа
route - управляет подключением контроллеров/моделей и вызывает ошибки
config - константы контроллера/модели/вида
bd - поключение к БД


КОНТРОЛЛЕРА всего 5:

default - общий вид сайта, header/footer, кнопка домой, форма регистрации
goods - таблица товаров +фильтр товаров (если категория выбрана в контроллере table)
category - таблица категорий
tables - страница выбранного товара, отражает все категории товара, с выбором категорий
admin_table - таблица связей для внесения изменений в БД
admin - контроллер редактирования БД, (в разработке)
out - контроллер выхода - завершает сессию и покидает админ-часть


 ВИДЫ:

шаблоны main.tpl.php и admin.tpl.php
остальные реализованы как слои


 ОШИБКИ и НЕДОЧЕТЫ:

1) ошибка с вызовом header в шаблоне, если роутер вызывается не на первой строке. Временное решение - вызывать header напрямую из роутера (29.12.2019 - исправлена)
2) ранее была ошибка с обновлением записей в БД - если изменять сразу и категорию и товар и описание - то сначала изменения вносились в предыдущие записи, а после обновления страницы
    в новые. Пример, есть третья строчка таблицы - телевизор из категории электронника и описание товара, изменяем на холодильник из категории быт. техника и описание нового товара -
    в БД меняется описание товара телевизор, все остальное корректно. Обновляем страницу - теперь наконец меняется описание товара Холодильник (06.01.2020 - исправлена)
3) Ошибка при добавлении в БД категории и товара при наличии такого пункта (07.01.2020 - исправлена)

4) В данный момент методы изменения и добавления в БД находятся в модели adminTableModel, а не в родительском классе Model (возможно будут перенесены для создания CRUD);
5) возможны ошибки при визуальном оформлении (стили css и flexbox);
6) 1. В данный момент не добавлено перенаправление после внесения данных в БД, обновление страницы не приведет к ошибке (протестировано), однако те же строки в БД снова обновляются;
   2. Очень удобный способ добавлять новые данные, однако стоит учитывать, что при добавлении такого же товара, но новой категории требует снова прописывать описание товара - решение
         добавить галочку (сохранить предыдущие данные).
   3. Данные в таблице товаров сортируются не по дате добавления, а по имени - и второй момент ссылки на новые товары отмечены как посещеные, и наоборот на старые товары как активные.

    !!!Подсказки по созданию контроллеров, моделей, видов!!!

1. Создать контроллер

class adminController extends Controller{
 private $pageTpl = "/views/admin.tpl.php";
  public function __construct() {
   $this->model = new adminModel();
   $this->view = new View();
  }
 public function default() {
  View::render($this->pageTpl, $this->pageData); //вызвать вид
 }
Если будет пагинация то обязательно:
  public function page() {
   $this->default(); //вернется в контроллер, всю остальную информацию берет из родительских классов
  }
Далее создаем свои методы.


2. Создать модель

//подключение реализовано в родительском классе Model

class adminModel extends Model {
 public static $id = idG; //здесь указываем поле по которому считаем количество записей БД (нужно для пагинации)
 public $maxNotes = 1;// сколько строк выводить на этой странице (нужно для пагинации)
  public function goods_tables() {
                                              //запрос в базу данных 1) указать группировку 2) указать LIMIT: 0 - показывать все, 1 - постранично
                                              //3) ограничение where - где 0 - отключить, а любой текст соответствует наименованию категории
    $result = self::goods_table(name, 1, 0);
    return $result;
  }
}


3. Создать вид

Если шаблон - добавить: $content->addRoute(), а также перед html тегами - $content->startRoute('название шаблона')
Нет обязательных требований.


Из роутера в каждый контроллер передается имя вызванного контроллера - теперь при создании
нового вида можно использовать переменные, вместо того чтобы везде прописывать имя контроллера

 Пример: пагинация - ожидаемый url

  http://catalog-site.example.ru/goods/1/ - где goods - контроллер goodsController
  http://catalog-site.example.ru/category/1/ где category - categoryController,

 вместо этого используется одинаковая конструкция:

  http://catalog-site.example.ru/$pageData[saveUrlBefore]/$pageData[save]/$i/$pageData[saveUrlAfter]

 где * $pageData[saveUrlBefore] = сохраненый путь до контроллера
     * $pageData[saveUrlAfter] = сохраненый путь после контроллера и его действия
     * $pageData[onlyTemplate] = имя шаблона - ситуация когда не нужно сохранять путь до контроллера, а просто вернуться в основную дирректорию шаблона

   пример: вместо http://catalog-site.example.ru/admin/category/1/goods/1/table/3
                  http://catalog-site.example.ru/admin/table/3 - где admin - это шаблон

     * $pageData[save] = имя текущего контроллера (goods, category, table, admin и тд.)



Кнопка "показывать все" просто отправляет по ссылке /category/1/goods/1/
путь сохраняется только в пределах этой ссылки или изменений урл напрямую пользователем
кнопка находится в шаблоне


Принцип работы метода пагинация:

В контроллере:
 $pagination = $this->model->Pagination('category'); // Подключение пагинации (прописываем 'category')
 $this->pageData['pagination'] = $pagination; // Отдать в Вид

В виде:
 echo($pageData['pagination']);

принцип:
 модель не трогаем - метод уже есть в родительской модели. Текущий контроллер его запустит и передаст ссылку(ссылку вносим сами).
 ссылка не что иное, как имя контроллера, одако внести это имя необходимо, так как пока контроллер не запущен - имя еще не известно.
 Метод пагинация сам вычисляет количесвто страниц на текущем контроллере, возвращает строку ссылок по типу 1 2 3 ...


ПОСЛЕДНИЕ ИЗМЕНЕНИЯ:

05.12.2019 - сокращен код в моделях и контроллерах
10.12.2019 - добавлена система шаблонов/слоев, оптимизация работы
17.12.2019 - пагинация теперь просто вызывается из вида; упрощена работа метода user_account; добавлена иконка
20.12.2019 - визуальные изменения файла error-404, ошибки вынесены в отдельный метод роутера, включаются в файле config.php, способ вызов роутера из шаблона упрощен (создание класса теперь вынесено в View.php)
26.12.2019 - переоформление: теперь можно в виде вызвать табличное (echo($pageData['printTable'])) оформление или блочное (echo($pageData['printDiv']))
                отображение пагинации в виде (echo $pageData['pagination']), добавлен метод перевода любого массива в обычный текст; стили теперь подключаются отдельно
29.12.2019 - теперь роутинг запускается в начале шаблона, а его контент где угодно методом render(); теперь есть проверка на наличие вызываемого метода в контроллере - добавлены новые проверки на вызов 404.php; если url заканчивается на '/' вызывается ошибка, убраны лишние '/' при переходах; протестирован на ошибки.
06.01.2020 - Работа с flexbox, визуальное оформление (теперь контент с блоками выталкивает блоки 'логотип' и 'вход' (header), что-то наподобие vk.com);
             Программирование: решение использовать АНОНИМНУЮ ФУНКЦИЮ (см. метод printDiv() в adminTableModel) - теперь список всех товаров и всех категорий открывается прямо в таблице заполнения БД, стандартно показывается актуальный пункт строки таблицы, но его можно изменить,
              актуальность товара и категории теперь тоже в расскрывающемся списке (но не всех товаров и категорий, а только текущего и обратное значение - если товар активен, то "1" - и обратная цифра "0" и наоборот) теперь можно корректно заполнять БД
07.01.2020  Исправления: была ошибка с выводом последней записи таблицы товаров($key в цикле переименован в $key2); была ошибка при добавлении в БД категории и товара при наличии такого пункта (добавлены ON DUPLICATE KEY UPDATE).



   До этого момента все обращения в БД решались одним методом и одной таблицей (создание сложной таблицы со связями), теперь добавлен еще один запрос на создание простой таблицы и можно изменить имя таблицы:
      goods_simple_table($table, $columnId = '', $column2 = ''), где $table - имя таблицы, $columnId = '' - это id, и $column2 = '' это колонки (перечислять через запятую, и заключить в кавычки).
         Используется сейчас только для отображения в таблице админстрирования вложенного списка всех товаров или категорий из БД без ограничений.

   Добавлен метод (будет доработан) в роутер startRoute() - теперь имя шаблона передается заранее перед html тегами: <?php $content->startRoute('default') ?>
      используется для видов account.tpl и accaunt.exit.tpl, (и для всех остальных) теперь кнопка "на главную возвращает в текущий шаблон", для выхода из админ нужно выйти
