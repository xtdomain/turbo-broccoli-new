Описание: 

Пишем свой фреймворк - версия 3 - 
теперь каждой таблице назначен контроллер (вместо действия), 
каждый контроллер помнит весь путь url вместе со страницей, 
каждый контроллер можно вызвать где угодно(задаются ограничения), 
теперь основной контроллер defaultController работает всегда в публичной части (в нем вид страницы, кнопка входа в личный кабинет) и нет необходимости
 вызывать экземпляры при каждом действии или прописывать его вид во всех контроллерах.

добавлена система шаблонов/слоев - если необшодим шаблон - в виде запускаем body-роутер (пример: Route::addRoute('название шаблона в url'), 
 в самом роутере в методе mainRoute() запускаем шаблон

можно изменить вид всех слоев - просто изменить html код шаблона.
в даный момент все контроллеры вызываются как в публичной части так и в админской - можно задавать ограничения в роутере
шаблонов и видов может быть сколько угодно

принцип работы:
 config запускает метод mainRoute() - этот метод запускает контроллер, который в свою очередь вызывает шаблон, последний подключает роутер.
 

 ФАЙЛЫ:

index.php - точка входа
route - управляет подключением контроллеров/моделей и вызывает ошибки
config - константы контроллера/модели/вида
bd - поключение к БД


КОНТРОЛЛЕРА всего 4:
 
default - общий вид сайта, header/footer, кнопка домой, форма регистрации
goods - таблица товаров +фильтр товаров (если категория выбрана в контроллере table)
category - таблица категорий
tables - страница выбранного товара, отражает все категории товара, с выбором категорий
admin - контроллер редактирования БД, (в разработке)
out - контроллер выхода - завершает сессию и покидает админ-часть


 ВИДЫ:

шаблоны main.tpl.php и admin.tpl.php
остальные реализованы как слои


 ОШИБКИ: 

1) пока нет возможности подключить роутинг header и footer в шаблоне, только body (header подключается, но является статичным)
2) ошибка с вызовом header в шаблоне, если body-роутер вызывается не на первой строке. Временное решение - вызывать header напрямую из роутера



    !!!Подсказки по созданию контроллеров, моделей, видов!!!

1. Создать контроллер

class adminController extends Controller{
 private $pageTpl = "/views/admin.tpl.php";
  public function __construct() {
   $this->model = new adminModel();
   $this->view = new View();
  }
 public function default() {
  View::render($this->pageTpl, $this->pageData); //вызвать вид
 }
Если будет пагинация то обязательно:
  public function page() {
   $this->default(); //вернется в контроллер, всю остальную информацию берет из родительских классов
  }
Далее создаем свои методы.


2. Создать модель

//подключение реализовано в родительском классе Model

class adminModel extends Model {
 public static $id = idG; //здесь указываем поле по которому считаем количество записей БД (нужно для пагинации)
 public $maxNotes = 1;// сколько строк выводить на этой странице (нужно для пагинации)
  public function goods_tables() {
                                              //запрос в базу данных 1) указать группировку 2) указать LIMIT: 0 - показывать все, 1 - постранично 
                                              //3) ограничение where - где 0 - отключить, а любой текст соответствует наименованию категории
    $result = self::goods_table(name, 1, 0);
    return $result;
  }
}


3. Создать вид

Если шаблон - добавить: Route::addRoute('название контроллера в url')
Нет обязательных требований.


Из роутера в каждый контроллер передается имя вызванного контроллера - теперь при создании 
нового вида можно использовать переменные, вместо того чтобы везде прописывать имя контроллера

 Пример: пагинация - ожидаемый url 

  http://catalog-site.example.ru/goods/1/ - где goods - контроллер goodsController
  http://catalog-site.example.ru/category/1/ где category - categoryController, 

 вместо этого используется одинаковая конструкция:

  http://catalog-site.example.ru/$pageData[saveUrlBefore]/$pageData[save]/$i/$pageData[saveUrlAfter]

 где * $pageData[saveUrlBefore] = сохраненый путь до контроллера
     * $pageData[saveUrlAfter] = сохраненый путь после контроллера и его действия
     * $pageData[onlyTemplate] = имя шаблона - ситуация когда не нужно сохранять путь до контроллера, а просто вернуться в основную дирректорию шаблона
 
   пример: вместо http://catalog-site.example.ru/admin/category/1/goods/1/table/3
                  http://catalog-site.example.ru/admin/table/3

     * $pageData[save] = имя текущего контроллера (goods, category, table, admin и тд.)



Кнопка "показывать все" просто отправляет по ссылке /category/1/goods/1/
путь сохраняется только в пределах этой ссылки или изменений урл напрямую пользователем
кнопка находится в шаблоне


ПОСЛЕДНИЕ ИЗМЕНЕНИЯ:

05.12.2019 - сокращен код в моделях и контроллерах
10.12.2019 - добавлена система шаблонов/слоев, оптимизация работы